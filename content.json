{"meta":{"title":"BlackBird's Blog","subtitle":"一个每天努力的菜鸡","description":"这世界上所有的不利状况，都是当事者能力不足导致的","author":"BlackBird","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-02-21T08:26:00.649Z","updated":"2021-02-21T08:26:00.649Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-02-21T04:38:58.484Z","updated":"2021-02-21T04:38:58.484Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2021-02-20T14:11:05.000Z","updated":"2021-02-20T14:16:59.263Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"BlackBird","date":"2021-02-20T02:40:14.000Z","updated":"2021-02-20T02:41:36.303Z","comments":true,"path":"bb/index.html","permalink":"http://example.com/bb/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-02-20T14:10:21.000Z","updated":"2021-02-21T04:40:10.573Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-02-20T14:10:34.000Z","updated":"2021-02-21T04:40:02.498Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-02-20T14:10:45.000Z","updated":"2021-02-21T04:41:32.053Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"第一届长安杯电子取证竞赛","slug":"第一届长安杯电子取证竞赛","date":"2021-02-21T01:33:15.000Z","updated":"2021-02-21T08:33:16.028Z","comments":true,"path":"2021/02/21/第一届长安杯电子取证竞赛/","link":"","permalink":"http://example.com/2021/02/21/%E7%AC%AC%E4%B8%80%E5%B1%8A%E9%95%BF%E5%AE%89%E6%9D%AF%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E7%AB%9E%E8%B5%9B/","excerpt":"","text":"","categories":[{"name":"电子取证学习","slug":"电子取证学习","permalink":"http://example.com/categories/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"电子取证","slug":"电子取证","permalink":"http://example.com/tags/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"}],"author":"BlackBird"},{"title":"2020moectf Reverse","slug":"2020moectf-Reverse","date":"2020-10-30T17:45:14.000Z","updated":"2021-02-21T08:47:12.587Z","comments":true,"path":"2020/10/31/2020moectf-Reverse/","link":"","permalink":"http://example.com/2020/10/31/2020moectf-Reverse/","excerpt":"Reverse是我得分第二高的模块。得这么多分，得感谢void大哥，然后感谢RX出题人跟我py……最后还是有三道题没做出来，唉~还是太菜了，我要继续向void大哥和RX师傅学习~","text":"Reverse是我得分第二高的模块。得这么多分，得感谢void大哥，然后感谢RX出题人跟我py……最后还是有三道题没做出来，唉~还是太菜了，我要继续向void大哥和RX师傅学习~ 我做出来的逆向工程入门指北感谢RX大神的学习资料，我就收下啦~~ Welcome To Re拖进IDA64，找到main函数，F5反编译： moectf{W3lc0me-T0_th3-W0rld_Of_R3v3rsE!} Thank you Javascript 一般而言，，运行一下，心里舒坦…… 但运行出来也没什么用。 混淆？？？我们查一下，关键字搜索“JS 混淆”： 什么？？？你没有搜索出来？ 别问，问就是你的搜索引擎辣鸡！ 混淆后： 1234567891011121314151617eval(function(p, a, c, k, e, d) &#123; e = function(c) &#123; return (c &lt; a ? &quot;&quot;: e(parseInt(c / a))) + ((c = c % a) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36)) &#125;; if (!&#x27;&#x27;.replace(/^/, String)) &#123; while (c--) d[e(c)] = k[c] || e(c); k = [function(e) &#123; return d[e] &#125;]; e = function() &#123; return &#x27;\\\\w+&#x27; &#125;; c = 1; &#125;; while (c--) if (k[c]) p = p.replace(new RegExp(&#x27;\\\\b&#x27; + e(c) + &#x27;\\\\b&#x27;, &#x27;g&#x27;), k[c]); return p;&#125; (&#x27;l 1=m(\\&#x27;k-4-2\\&#x27;);i j 6()&#123;1.2(\\&#x27;q r p --n o b\\&#x27;);1.2(5 1.4());1.2(`a $&#123;5 1.d(\\&#x27;9 h e?\\&#x27;)&#125;!`);f 3=g;F(!3)&#123;1.2(\\&#x27;D E 7 B 8:\\&#x27;);3=5 1.4()===\\&#x27;G&#123;H\\&#x27;+\\&#x27;c\\&#x27;+\\&#x27;v\\&#x27;+\\&#x27;w\\&#x27;+\\&#x27;0\\&#x27;+\\&#x27;u-\\&#x27;+\\&#x27;s\\&#x27;+\\&#x27;t\\&#x27;+\\&#x27;z\\&#x27;+\\&#x27;A\\&#x27;+\\&#x27;!&#125;\\&#x27;&#125;1.2(\\&#x27;y! x C 7 8!\\&#x27;)&#125;6();&#x27;, 44, 44, &#x27;|io|write|saidHi|read|await|main|the|flag|Who|Hello|Reverier||ask|you|let|false|are|async|function|console|const|require|written|by|ThankYouJavaScript|MoeCTF|2020|Jav|aS||k_|Y|You|Congratulations|cr|ipt|true|find|Please|input|while|moectf|Fx&#x27;.split(&#x27;|&#x27;), 0, &#123;&#125;)) 解混淆后： 1234567891011121314const io=require(&#x27;console-read-write&#x27;);async function main()&#123; io.write(&#x27;MoeCTF 2020 ThankYouJavaScript --written by Reverier&#x27;); io.write(await io.read()); io.write(`Hello $&#123;await io.ask(&#x27;Who are you?&#x27;)&#125;!`); let saidHi=false; while(!saidHi) &#123; io.write(&#x27;Please input the true flag:&#x27;); saidHi=await io.read()===&#x27;moectf&#123;Fx&#x27;+&#x27;c&#x27;+&#x27;k_&#x27;+&#x27;Y&#x27;+&#x27;0&#x27;+&#x27;u-&#x27;+&#x27;Jav&#x27;+&#x27;aS&#x27;+&#x27;cr&#x27;+&#x27;ipt&#x27;+&#x27;!&#125;&#x27; &#125; io.write(&#x27;Congratulations! You find the flag!&#x27;)&#125;main(); moectf{Fxck_Y0u-JavaScript!} Simple Re先运行一下： 嗯？？？竟然不直接给我flag，把他交给我的女朋友IDA，让我女朋友来收拾他！！！ 发现关键比较！还是我女朋友厉害！！！ 思路比较清晰，就是把我们输进去的东西进行一堆异或操作，然后和加密过的flag比较，也正应了提示：异或异或！ 那我们把加密过的flag抠出来，然后写一个程序的逆向算法就ok了，但是异或怎么逆呢？？？ 性质 1、交换律 2、结合律，即(a ^ b) ^ c == a ^ ( b ^ c) 3、对于任何数x，都有x ^ x=0，x ^ 0=x 4、自反性 A XOR B XOR B = A xor 0 = A 这里利用了异或操作的交换率和自反性 直接贴解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int main(int)&#123; string aim=&quot;rpz|kydKw^qTl@Y/m2f/J-@o^k.,qkb&quot;; for (int i = 0; i &lt;= 30; ++i ) aim[i] ^= 0x17; for (int j = 0; j &lt;= 30; ++j ) aim[j] ^= 0x39u; for (int k = 0; k &lt;= 30; ++k ) aim[k] ^= 0x4Bu; for (int l = 0; l &lt;= 30; ++l ) aim[l] ^= 0x4Au; for (int m = 0; m &lt;= 30; ++m ) aim[m] ^= 0x49u; for (int n = 0; n &lt;= 30; ++n ) aim[n] ^= 0x26u; for (int ii = 0; ii &lt;= 30; ++ii ) aim[ii] ^= 0x15u; for (int jj = 0; jj &lt;= 30; ++jj ) aim[jj] ^= 0x61u; for (int kk = 0; kk &lt;= 30; ++kk ) aim[kk] ^= 0x56u; for (int ll = 0; ll &lt;= 30; ++ll ) aim[ll] ^= 0x1Bu; for (int mm = 0; mm &lt;= 30; ++mm ) aim[mm] ^= 0x21u; for (int nn = 0; nn &lt;= 30; ++nn ) aim[nn] ^= 0x40u; for (int i1 = 0; i1 &lt;= 30; ++i1 ) aim[i1] ^= 0x57u; for (int i2 = 0; i2 &lt;= 30; ++i2 ) aim[i2] ^= 0x2Eu; for (int i3 = 0; i3 &lt;= 30; ++i3 ) aim[i3] ^= 0x49u; for (int i4 = 0; i4 &lt;= 30; ++i4 ) aim[i4] ^= 0x37u; cout&lt;&lt;aim; return 0;&#125; 基本上是从女朋友IDA那里直接拿的，就加了一点点…… Protection 这个提示已经很明显了，“给程序套一层衣服”=&gt;”壳”： DIE查一下壳：UPX3.96，我们直接在github上面找UPX3.96壳的脱壳机进行“脱衣，扒光”： 我这个时候试运行一下： 哼~西内！竟然不直接给我flag，那你去见见我女朋友吧： 哟西~还是女朋友靠谱！！！程序逻辑很简单，还是异或操作，直接贴解密程序： 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string x=&quot;aouv#@!V08asdozpnma&amp;*#%!$^&amp;*&quot;; char v5[30]; int y[30]=&#123;12,0,16,21,87,38,90,35,64,64,62,66,55,48,9,25,3,29,80,67,7,87,21,126,81,109,67,87&#125;; for (int i = 0; i &lt;= 27; ++i ) v5[i]= y[i] ^ x[i]; cout&lt;&lt;v5; return 0;&#125; moectf{upx_1S_simp1e-t0_u3e} Real EasyPython下载下来是.pyc文件，这个文件可以简单地理解成py的编译文件，所以我们按照常规思路，我们需要把这个反编译。搜索关键字“Python 反编译”: 可以在第一个网站上在线反编译，也可以在第二个的里面找到工具uncompyle6，我们这里讲一下python反编译工具的使用： pip install uncompyle6 uncompyle6 puzzle.pyc &gt; puzzle_dec.py 我们下来直接看反编译的python脚本： 1234567891011121314151617key = [ 115, 76, 50, 116, 90, 50, 116, 90, 115, 110, 48, 47, 87, 48, 103, 50, 106, 126, 90, 48, 103, 116, 126, 90, 85, 126, 115, 110, 105, 104, 35]print(&#x27;Input your flag: &#x27;, end=&#x27;&#x27;)flag = input()out = []for i in flag: out.append(ord(i) &gt;&gt; 4 ^ ord(i))if len(out) != len(key): print(&#x27;TRY AGAIN!&#x27;) exit()for i in range(len(out)): if out[i] != key[i]: print(&#x27;TRY AGAIN!&#x27;) exit()print(&#x27;you are right! the flag is : moectf&#123;%s&#125;&#x27; % flag) 程序思路很清晰，但是这里有个小点：脚本里面的&gt;&gt;操作怎么处理呢？？？直接&lt;&lt;不就完了。错！因为&gt;&gt;操作是将该数据转化为二进制然后抹去最后四位；而&lt;&lt;操作是将该数据转化为二进制，然后直接在最后面补上四个’0’。所以这里的&gt;&gt;暴力处理一下，上脚本： 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int ori[50]=&#123;115, 76, 50, 116, 90, 50, 116, 90, 115, 110, 48, 47, 87, 48, 103, 50, 106, 126, 90, 48, 103, 116, 126, 90, 85, 126, 115, 110, 105, 104, 35&#125;; char rel[50]; for(int i=0;i&lt;33;i++) &#123; for(int j=33;j&lt;127;j++) if((j&gt;&gt;4^j)==ori[i]) rel[i]=j; &#125; cout&lt;&lt;rel; return 0;&#125;# moectf&#123;tH1s_1s_th3-R3a1ly_3asy_Python!&#125; RxEncode这个题……直接找我女朋友，我相信我搞不定，必须要找女朋友来帮忙。在IDA先查一下字符串： 看到那么一串字符串，盲猜换表base64然后看一看主函数的思路： 程序的思路： 输入flag=&gt;“换表base64”加密=&gt;与程序内部数据对比=&gt;yes/no 那我们的思路就是： 扣出内部数据=&gt;“换表base64”解密=&gt;flag 但是我们发现一个问题，就是程序内部的数据竟然不是字符，而是十六进制的形式： 怎么办呢？？？这里涉及到了另外一个知识点“大小端序”，我们看到的v2、v15、v16、v17都是小端序存储显示出来的，我们进入hex窗口或者自己手动dump出来正常的内容： \\x9A\\x87\\x9C\\xB5\\xFE\\x58\\xD1\\x4A\\xFE\\x0B\\xED\\x6C\\xFA\\xFD\\xEB\\xCB\\xE8\\x34\\xA3\\x43\\x8E\\xA3\\x47\\x7A 下来就是一个换表base64的问题了： 123456import base64flag_en = b&#x27;\\x9A\\x87\\x9C\\xB5\\xFE\\x58\\xD1\\x4A\\xFE\\x0B\\xED\\x6C\\xFA\\xFD\\xEB\\xCB\\xE8\\x34\\xA3\\x43\\x8E\\xA3\\x47\\x7A&#x27;flag = str(base64.b64encode(flag_en)).replace(&#x27;5&#x27;, &#x27;&#123;&#x27;).replace(&#x27;6&#x27;, &#x27;&#125;&#x27;)print(flag)# moectf&#123;Y0Ur+C+1s+v3ry+g0o0OOo0d&#125; EasyCommonLisp这个题真是令人头大！！！为了做这个题，还得去学习一下clisp这门语言 “一名真正的CTF选手，应该在15mins之内学会任何一门语言！！！（傲娇脸)” ——XDSEC_Reverier（RX 题目： 12345(defparameter +alphabet+&quot;AB#DEd@f&amp;hi!klmnLMw3^5678N&#125;PF|HIxyz012JKYZab%Q&#123;S(UVWX-pqrs&quot;)(defparameter +len+(length +alphabet+))(defun divmod(number divisor)(values(floor(&#x2F; number divisor))(mod number divisor)))(defun encode(str)(let((value 0)(rstr(reverse str))(output(make-string-output-stream))(npad 0))(loop for i from 0 to(1- (length str))do(setf value(+ value(*(char-code(elt rstr i))(expt 256 i)))))(loop while(&gt;&#x3D; value +len+)do(multiple-value-bind(new-value mod)(divmod value +len+)(setf value new-value)(write-char(elt +alphabet+ mod) output)))(write-char(elt +alphabet+ value)output)(loop for char across str do(if(char-equal char #\\Nul)(incf npad)(return)))(concatenate &#39;string(coerce(loop for i from 1 to npad collecting #\\1)&#39;string)(reverse(get-output-stream-string output)))))(print(encode &quot;moectf&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;));;;; eof;;;; flag is &quot;&amp;Dx16Y!x3((xYDlShWbQ5hmzWf3EZly6h8UwD#d-1-&amp;#WlDHJaxM5qAzlPP&quot; 手动格式化一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566(defparameter +alphabet+&quot;AB#DEd@f&amp;hi!klmnLMw3^5678N&#125;PF|HIxyz012JKYZab%Q&#123;S(UVWX-pqrs&quot;);(defparameter +len+(length +alphabet+))( defun divmod(number divisor ) ( values(floor(&#x2F; number divisor))(mod number divisor) ))( defun encode(str) ( let ( (value 0) (rstr(reverse str)) (output(make-string-output-stream)) (npad 0) ) ( loop for i from 0 to(1- (length str)) do ( setf value ( + value(*(char-code(elt rstr i))(expt 256 i)) ) ) ) ( loop while(&gt;&#x3D; value +len+) do ( multiple-value-bind (new-value mod) (divmod value +len+) (setf value new-value) (write-char(elt +alphabet+ mod) output) ) ) ( write-char(elt +alphabet+ value)output ) ( loop for char across str do ( if(char-equal char #\\Nul) (incf npad);npad++; (return) ) ) (print npad) ( concatenate &#39;string(coerce(loop for i from 1 to npad collecting #\\1)&#39;string) ( reverse(get-output-stream-string output) ) ) ))(print(encode &quot;moectf&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;));;;; eof;;;; flag is &quot;&amp;Dx16Y!x3((xYDlShWbQ5hmzWf3EZly6h8UwD#d-1-&amp;#WlDHJaxM5qAzlPP&quot; 虽然比题目好看一点，但还是很难看…… 这个题的解题过程就是：学会clisp=&gt;读懂题目=&gt;敲成python=&gt;写逆程序 转换成python: 12345678910111213141516171819202122232425262728alphabet = &quot;AB#DEd@f&amp;hi!klmnLMw3^5678N&#125;PF|HIxyz012JKYZab%Q&#123;S(UVWX-pqrs&quot;length = len(alphabet)def divmod(a,b): return a//b,a%bdef reverse(s): return &#x27;&#x27;.join(reversed(s))def encode(str): ans=&quot;&quot; value = 0 rstr = reverse(str) napd = 0 for i in range(0,len(str)): value = value + ord(rstr[i])*(256**i) while value&gt;=length: value, mod = divmod(value, length) ans=ans+alphabet[mod] ans=ans+alphabet[value] ans=reverse(ans) return ansprint(encode(&quot;moectf&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;))#&quot;&amp;Dx16Y!x3((xYDlShWbQ5hmzWf3EZly6h8UwD#d-1-&amp;#WlDHJaxM5qAzlPP&quot; 然后写一下解密脚本： 12345678910111213alphabet = &quot;AB#DEd@f&amp;hi!klmnLMw3^5678N&#125;PF|HIxyz012JKYZab%Q&#123;S(UVWX-pqrs&quot;ans = &quot;&amp;Dx16Y!x3((xYDlShWbQ5hmzWf3EZly6h8UwD#d-1-&amp;#WlDHJaxM5qAzlPP&quot;def reverse(s): return &#x27;&#x27;.join(reversed(s))ans = reverse(ans)value = alphabet.find(ans[len(ans)-1])for i in range(0,58): value = len(alphabet)*value + alphabet.find(ans[len(ans)-2-i])a = hex(value)flag = str(a)flag = flag[2:len(flag)-1]print(flag.decode(&#x27;hex&#x27;))# moectf&#123;woO0Oow_Y0u-ar3_th3_g0D_0f_LIIIISP!&#125; 对了，解密脚本是python2写的，因为在python3环境下会有str和bytes两种数据类型之间奇奇怪怪的错误…… EzJava据名字猜考点：java逆向。 先找java逆向工具，这里我用的是jd.gui，把题目拖进去就可以看到java代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.BufferedReader;import java.io.InputStreamReader;public class EasyJava &#123; public static void main(String[] paramArrayOfString) &#123; System.out.println(&quot;MoeCTF 2020 EasyJava --by Reverier&quot;); System.out.println(&quot;Input your flag and I will check it:&quot;); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); String str = null; int[] arrayOfInt = &#123; 43, 23, 23, 62, 110, 66, 94, 99, 126, 68, 43, 62, 76, 110, 22, 5, 15, 111, 86, 75, 78, 83, 86, 0, 85, 86 &#125;; try &#123; str = bufferedReader.readLine(); &#125; catch (Exception exception) &#123; System.out.println(&quot;ERROR: Undefined Exception.&quot;); &#125; if (str.isEmpty()) &#123; System.out.println(&quot;Nothing received.&quot;); &#125; else &#123; if (str.length() != 35) &#123; //flag长度35 System.out.println(&quot;Rua~~~Wrong!&quot;); return; &#125; String str1 = str.substring(0, 7); if (!str1.equals(&quot;moectf&#123;&quot;)) &#123; System.out.println(&quot;Rua~~~Wrong!&quot;); return; &#125; String str2 = str.substring(7, str.length() - 1); //把flag的头&quot;moectf&#123;&quot;和最后面的&quot;&#125;&quot;脱掉 //核心代码段 for (byte b = 0; b &lt; str2.length() - 1; b++) &#123; char c1 = str2.charAt(b); char c2 = str2.charAt(b + 1); int i = c1 ^ c2; if (i != arrayOfInt[b]) &#123; System.out.println(&quot;Rua~~~Wrong!&quot;); return; &#125; &#125; System.out.println(&quot;Congratulations!&quot;); &#125; &#125;&#125; 我们只需要仔细看核心代码段，又是异或……自反性，搞他！！！ 因为flag一共35位，掐头去尾还剩27位，但是它内部数据只有26位，所以我们没有办法逆向搞并且flag是有意义字符串，所以这里还是选择正向暴力！！！ 暴力出奇迹，打表得省一 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int b[50]=&#123;43,23,23,62,110,66,94,99,126,68,43,62,76,110,22,5,15,111,86,75,78,83,86,0,85,86&#125;; for(int n=32;n&lt;=126;n++) &#123; char rel[100]; rel[0]=n; for(int i=0;i&lt;26;i++) rel[i+1]=b[i]^rel[i]; cout&lt;&lt;rel&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125; moectf{Java_1s-N0t_a-CUP_0f-c0ff3e} RollCall这个题比较特殊…… 不管是题干还是hint都在暗示我们一件事情这程序不能逆向！！！我们看一下这个程序包里面有什么？？？ 嗯？.sqlite文件？？？这是一个数据库文件，那我们就可以猜到学生的各项数据他是存储在数据库里面，我们如果不能在程序添加性别为2，那我们可以直接对数据库操作。我是打开了wsl然后装一个 sqlite数据库，用insert命令向数据库里面插入一条性别为2的信息： sudo apt install sqlite3 sqlite3 UserData .tables //查看该库下面的表，获取该库下表：students PRAGMA table_info(students)；//查看students表下所有字段：ID,name,sex,averange INSERT INTO students VALUES (233, ‘BlackBird’, 2, 2 ); 然后再打开程序： MidPythonemmmm……pyc文件逆向先反编译，还是上面的那个uncompyle6，但是，报错了？？？我们打开“半生半熟”（一半py一半字节码）的py文件：(超长代码警告！！！) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616# uncompyle6 version 3.7.3# Python bytecode 3.8 (3413)# Decompiled from: Python 3.8.5 (tags/v3.8.5:580fbb0, Jul 20 2020, 15:57:54) [MSC v.1924 64 bit (AMD64)]# Embedded file name: ./EzPython/source.py# Compiled at: 2020-07-25 16:57:06# Size of source mod 2**32: 5784 bytesInstruction context: L. 76 414 JUMP_BACK 32 &#x27;to 32&#x27;-&gt; 416 JUMP_FORWARD 430 &#x27;to 430&#x27; 418_0 COME_FROM 60 &#x27;60&#x27;Instruction context: L. 118 414 JUMP_BACK 32 &#x27;to 32&#x27;-&gt; 416 JUMP_FORWARD 430 &#x27;to 430&#x27; 418_0 COME_FROM 60 &#x27;60&#x27;T_letter = [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]def Create_Matrix(key): key = Remove_Duplicates(key) key = key.replace(&#x27; &#x27;, &#x27;&#x27;) j = 0 for i in range(len(key)): T_letter[j] += key[i] if 0 == (i + 1) % 5: j += 1def Remove_Duplicates(key): key = key.upper() _key = &#x27;&#x27; for ch in key: if ch == &#x27;I&#x27;: ch = &#x27;J&#x27; if ch in _key: continue else: _key += ch return _keydef Get_MatrixIndex(ch): for i in range(len(T_letter)): for j in range(len(T_letter)): if ch == T_letter[i][j]: return ( i, j)def Encrypt--- This code section failed: --- L. 44 0 LOAD_STR &#x27;&#x27; 2 STORE_FAST &#x27;ciphertext&#x27; L. 46 4 LOAD_GLOBAL len 6 LOAD_FAST &#x27;plaintext&#x27; 8 CALL_FUNCTION_1 1 &#x27;&#x27; 10 LOAD_CONST 2 12 BINARY_MODULO 14 LOAD_CONST 0 16 COMPARE_OP != 18 POP_JUMP_IF_FALSE 28 &#x27;to 28&#x27; L. 47 20 LOAD_FAST &#x27;plaintext&#x27; 22 LOAD_STR &#x27;Z&#x27; 24 INPLACE_ADD 26 STORE_FAST &#x27;plaintext&#x27; 28_0 COME_FROM 18 &#x27;18&#x27; L. 49 28 LOAD_CONST 0 30 STORE_FAST &#x27;i&#x27; L. 50 32 LOAD_FAST &#x27;i&#x27; 34 LOAD_GLOBAL len 36 LOAD_FAST &#x27;plaintext&#x27; 38 CALL_FUNCTION_1 1 &#x27;&#x27; 40 COMPARE_OP &lt; 42_44 POP_JUMP_IF_FALSE 440 &#x27;to 440&#x27; L. 51 46 LOAD_CONST True 48 LOAD_FAST &#x27;plaintext&#x27; 50 LOAD_FAST &#x27;i&#x27; 52 BINARY_SUBSCR 54 LOAD_METHOD isalpha 56 CALL_METHOD_0 0 &#x27;&#x27; 58 COMPARE_OP == 60_62 POP_JUMP_IF_FALSE 418 &#x27;to 418&#x27; L. 52 64 LOAD_FAST &#x27;i&#x27; 66 LOAD_CONST 1 68 BINARY_ADD 70 STORE_FAST &#x27;j&#x27; L. 53 72 LOAD_FAST &#x27;j&#x27; 74 LOAD_GLOBAL len 76 LOAD_FAST &#x27;plaintext&#x27; 78 CALL_FUNCTION_1 1 &#x27;&#x27; 80 COMPARE_OP &lt; 82_84 POP_JUMP_IF_FALSE 406 &#x27;to 406&#x27; L. 54 86 LOAD_CONST True 88 LOAD_FAST &#x27;plaintext&#x27; 90 LOAD_FAST &#x27;j&#x27; 92 BINARY_SUBSCR 94 LOAD_METHOD isalpha 96 CALL_METHOD_0 0 &#x27;&#x27; 98 COMPARE_OP == 100_102 POP_JUMP_IF_FALSE 396 &#x27;to 396&#x27; L. 55 104 LOAD_STR &#x27;I&#x27; 106 LOAD_FAST &#x27;plaintext&#x27; 108 LOAD_FAST &#x27;i&#x27; 110 BINARY_SUBSCR 112 LOAD_METHOD upper 114 CALL_METHOD_0 0 &#x27;&#x27; 116 COMPARE_OP == 118 POP_JUMP_IF_FALSE 130 &#x27;to 130&#x27; L. 56 120 LOAD_GLOBAL Get_MatrixIndex 122 LOAD_STR &#x27;J&#x27; 124 CALL_FUNCTION_1 1 &#x27;&#x27; 126 STORE_FAST &#x27;x&#x27; 128 JUMP_FORWARD 146 &#x27;to 146&#x27; 130_0 COME_FROM 118 &#x27;118&#x27; L. 58 130 LOAD_GLOBAL Get_MatrixIndex L. 59 132 LOAD_FAST &#x27;plaintext&#x27; 134 LOAD_FAST &#x27;i&#x27; 136 BINARY_SUBSCR 138 LOAD_METHOD upper 140 CALL_METHOD_0 0 &#x27;&#x27; L. 58 142 CALL_FUNCTION_1 1 &#x27;&#x27; 144 STORE_FAST &#x27;x&#x27; 146_0 COME_FROM 128 &#x27;128&#x27; L. 60 146 LOAD_STR &#x27;I&#x27; 148 LOAD_FAST &#x27;plaintext&#x27; 150 LOAD_FAST &#x27;j&#x27; 152 BINARY_SUBSCR 154 LOAD_METHOD upper 156 CALL_METHOD_0 0 &#x27;&#x27; 158 COMPARE_OP == 160 POP_JUMP_IF_FALSE 172 &#x27;to 172&#x27; L. 61 162 LOAD_GLOBAL Get_MatrixIndex 164 LOAD_STR &#x27;J&#x27; 166 CALL_FUNCTION_1 1 &#x27;&#x27; 168 STORE_FAST &#x27;y&#x27; 170 JUMP_FORWARD 188 &#x27;to 188&#x27; 172_0 COME_FROM 160 &#x27;160&#x27; L. 63 172 LOAD_GLOBAL Get_MatrixIndex 174 LOAD_FAST &#x27;plaintext&#x27; 176 LOAD_FAST &#x27;j&#x27; 178 BINARY_SUBSCR 180 LOAD_METHOD upper 182 CALL_METHOD_0 0 &#x27;&#x27; 184 CALL_FUNCTION_1 1 &#x27;&#x27; 186 STORE_FAST &#x27;y&#x27; 188_0 COME_FROM 170 &#x27;170&#x27; L. 65 188 LOAD_FAST &#x27;x&#x27; 190 LOAD_CONST 0 192 BINARY_SUBSCR 194 LOAD_FAST &#x27;y&#x27; 196 LOAD_CONST 0 198 BINARY_SUBSCR 200 COMPARE_OP == 202_204 POP_JUMP_IF_FALSE 268 &#x27;to 268&#x27; L. 66 206 LOAD_FAST &#x27;ciphertext&#x27; 208 LOAD_FAST &#x27;T_letter&#x27; 210 LOAD_FAST &#x27;x&#x27; 212 LOAD_CONST 0 214 BINARY_SUBSCR 216 BINARY_SUBSCR 218 LOAD_FAST &#x27;x&#x27; 220 LOAD_CONST 1 222 BINARY_SUBSCR 224 LOAD_CONST 1 226 BINARY_ADD L. 67 228 LOAD_CONST 5 L. 66 230 BINARY_MODULO 232 BINARY_SUBSCR L. 67 234 LOAD_FAST &#x27;T_letter&#x27; 236 LOAD_FAST &#x27;y&#x27; 238 LOAD_CONST 0 240 BINARY_SUBSCR 242 BINARY_SUBSCR 244 LOAD_FAST &#x27;y&#x27; 246 LOAD_CONST 1 248 BINARY_SUBSCR 250 LOAD_CONST 1 252 BINARY_ADD 254 LOAD_CONST 5 256 BINARY_MODULO 258 BINARY_SUBSCR L. 66 260 BINARY_ADD 262 INPLACE_ADD 264 STORE_FAST &#x27;ciphertext&#x27; 266 JUMP_ABSOLUTE 406 &#x27;to 406&#x27; 268_0 COME_FROM 202 &#x27;202&#x27; L. 68 268 LOAD_FAST &#x27;x&#x27; 270 LOAD_CONST 1 272 BINARY_SUBSCR 274 LOAD_FAST &#x27;y&#x27; 276 LOAD_CONST 1 278 BINARY_SUBSCR 280 COMPARE_OP == 282_284 POP_JUMP_IF_FALSE 348 &#x27;to 348&#x27; L. 69 286 LOAD_FAST &#x27;ciphertext&#x27; 288 LOAD_FAST &#x27;T_letter&#x27; 290 LOAD_FAST &#x27;x&#x27; 292 LOAD_CONST 1 294 BINARY_SUBSCR 296 LOAD_CONST 1 298 BINARY_ADD L. 70 300 LOAD_CONST 5 L. 69 302 BINARY_MODULO 304 BINARY_SUBSCR L. 70 306 LOAD_FAST &#x27;x&#x27; 308 LOAD_CONST 0 310 BINARY_SUBSCR L. 69 312 BINARY_SUBSCR L. 70 314 LOAD_FAST &#x27;T_letter&#x27; 316 LOAD_FAST &#x27;y&#x27; 318 LOAD_CONST 1 320 BINARY_SUBSCR 322 LOAD_CONST 1 324 BINARY_ADD 326 LOAD_CONST 5 328 BINARY_MODULO 330 BINARY_SUBSCR 332 LOAD_FAST &#x27;y&#x27; 334 LOAD_CONST 0 336 BINARY_SUBSCR 338 BINARY_SUBSCR L. 69 340 BINARY_ADD 342 INPLACE_ADD 344 STORE_FAST &#x27;ciphertext&#x27; 346 JUMP_ABSOLUTE 406 &#x27;to 406&#x27; 348_0 COME_FROM 282 &#x27;282&#x27; L. 72 348 LOAD_FAST &#x27;ciphertext&#x27; 350 LOAD_FAST &#x27;T_letter&#x27; 352 LOAD_FAST &#x27;x&#x27; 354 LOAD_CONST 0 356 BINARY_SUBSCR 358 BINARY_SUBSCR 360 LOAD_FAST &#x27;y&#x27; 362 LOAD_CONST 1 364 BINARY_SUBSCR 366 BINARY_SUBSCR 368 LOAD_FAST &#x27;T_letter&#x27; 370 LOAD_FAST &#x27;y&#x27; 372 LOAD_CONST 0 374 BINARY_SUBSCR 376 BINARY_SUBSCR 378 LOAD_FAST &#x27;x&#x27; 380 LOAD_CONST 1 382 BINARY_SUBSCR 384 BINARY_SUBSCR 386 BINARY_ADD 388 INPLACE_ADD 390 STORE_FAST &#x27;ciphertext&#x27; L. 73 392_394 BREAK_LOOP 406 &#x27;to 406&#x27; 396_0 COME_FROM 100 &#x27;100&#x27; L. 74 396 LOAD_FAST &#x27;j&#x27; 398 LOAD_CONST 1 400 INPLACE_ADD 402 STORE_FAST &#x27;j&#x27; 404 JUMP_BACK 72 &#x27;to 72&#x27; 406_0 COME_FROM 82 &#x27;82&#x27; L. 75 406 LOAD_FAST &#x27;j&#x27; 408 LOAD_CONST 1 410 BINARY_ADD 412 STORE_FAST &#x27;i&#x27; L. 76 414 JUMP_BACK 32 &#x27;to 32&#x27; 416 JUMP_FORWARD 430 &#x27;to 430&#x27; 418_0 COME_FROM 60 &#x27;60&#x27; L. 78 418 LOAD_FAST &#x27;ciphertext&#x27; 420 LOAD_FAST &#x27;plaintext&#x27; 422 LOAD_FAST &#x27;i&#x27; 424 BINARY_SUBSCR 426 INPLACE_ADD 428 STORE_FAST &#x27;ciphertext&#x27; 430_0 COME_FROM 416 &#x27;416&#x27; L. 79 430 LOAD_FAST &#x27;i&#x27; 432 LOAD_CONST 1 434 INPLACE_ADD 436 STORE_FAST &#x27;i&#x27; 438 JUMP_BACK 32 &#x27;to 32&#x27; 440_0 COME_FROM 42 &#x27;42&#x27; L. 81 440 LOAD_FAST &#x27;ciphertext&#x27; 442 RETURN_VALUE -1 RETURN_LAST Parse error at or near `JUMP_FORWARD&#x27; instruction at offset 416def Decrypt--- This code section failed: --- L. 87 0 LOAD_STR &#x27;&#x27; 2 STORE_FAST &#x27;plaintext&#x27; L. 88 4 LOAD_GLOBAL len 6 LOAD_FAST &#x27;ciphertext&#x27; 8 CALL_FUNCTION_1 1 &#x27;&#x27; 10 LOAD_CONST 2 12 BINARY_MODULO 14 LOAD_CONST 0 16 COMPARE_OP != 18 POP_JUMP_IF_FALSE 28 &#x27;to 28&#x27; L. 89 20 LOAD_FAST &#x27;ciphertext&#x27; 22 LOAD_STR &#x27;Z&#x27; 24 INPLACE_ADD 26 STORE_FAST &#x27;ciphertext&#x27; 28_0 COME_FROM 18 &#x27;18&#x27; L. 91 28 LOAD_CONST 0 30 STORE_FAST &#x27;i&#x27; L. 92 32 LOAD_FAST &#x27;i&#x27; 34 LOAD_GLOBAL len 36 LOAD_FAST &#x27;ciphertext&#x27; 38 CALL_FUNCTION_1 1 &#x27;&#x27; 40 COMPARE_OP &lt; 42_44 POP_JUMP_IF_FALSE 440 &#x27;to 440&#x27; L. 93 46 LOAD_CONST True 48 LOAD_FAST &#x27;ciphertext&#x27; 50 LOAD_FAST &#x27;i&#x27; 52 BINARY_SUBSCR 54 LOAD_METHOD isalpha 56 CALL_METHOD_0 0 &#x27;&#x27; 58 COMPARE_OP == 60_62 POP_JUMP_IF_FALSE 418 &#x27;to 418&#x27; L. 94 64 LOAD_FAST &#x27;i&#x27; 66 LOAD_CONST 1 68 BINARY_ADD 70 STORE_FAST &#x27;j&#x27; L. 95 72 LOAD_FAST &#x27;j&#x27; 74 LOAD_GLOBAL len 76 LOAD_FAST &#x27;ciphertext&#x27; 78 CALL_FUNCTION_1 1 &#x27;&#x27; 80 COMPARE_OP &lt; 82_84 POP_JUMP_IF_FALSE 406 &#x27;to 406&#x27; L. 96 86 LOAD_CONST True 88 LOAD_FAST &#x27;ciphertext&#x27; 90 LOAD_FAST &#x27;j&#x27; 92 BINARY_SUBSCR 94 LOAD_METHOD isalpha 96 CALL_METHOD_0 0 &#x27;&#x27; 98 COMPARE_OP == 100_102 POP_JUMP_IF_FALSE 396 &#x27;to 396&#x27; L. 97 104 LOAD_STR &#x27;I&#x27; 106 LOAD_FAST &#x27;ciphertext&#x27; 108 LOAD_FAST &#x27;i&#x27; 110 BINARY_SUBSCR 112 LOAD_METHOD upper 114 CALL_METHOD_0 0 &#x27;&#x27; 116 COMPARE_OP == 118 POP_JUMP_IF_FALSE 130 &#x27;to 130&#x27; L. 98 120 LOAD_GLOBAL Get_MatrixIndex 122 LOAD_STR &#x27;J&#x27; 124 CALL_FUNCTION_1 1 &#x27;&#x27; 126 STORE_FAST &#x27;x&#x27; 128 JUMP_FORWARD 146 &#x27;to 146&#x27; 130_0 COME_FROM 118 &#x27;118&#x27; L. 100 130 LOAD_GLOBAL Get_MatrixIndex L. 101 132 LOAD_FAST &#x27;ciphertext&#x27; 134 LOAD_FAST &#x27;i&#x27; 136 BINARY_SUBSCR 138 LOAD_METHOD upper 140 CALL_METHOD_0 0 &#x27;&#x27; L. 100 142 CALL_FUNCTION_1 1 &#x27;&#x27; 144 STORE_FAST &#x27;x&#x27; 146_0 COME_FROM 128 &#x27;128&#x27; L. 102 146 LOAD_STR &#x27;I&#x27; 148 LOAD_FAST &#x27;ciphertext&#x27; 150 LOAD_FAST &#x27;j&#x27; 152 BINARY_SUBSCR 154 LOAD_METHOD upper 156 CALL_METHOD_0 0 &#x27;&#x27; 158 COMPARE_OP == 160 POP_JUMP_IF_FALSE 172 &#x27;to 172&#x27; L. 103 162 LOAD_GLOBAL Get_MatrixIndex 164 LOAD_STR &#x27;J&#x27; 166 CALL_FUNCTION_1 1 &#x27;&#x27; 168 STORE_FAST &#x27;y&#x27; 170 JUMP_FORWARD 188 &#x27;to 188&#x27; 172_0 COME_FROM 160 &#x27;160&#x27; L. 105 172 LOAD_GLOBAL Get_MatrixIndex 174 LOAD_FAST &#x27;ciphertext&#x27; 176 LOAD_FAST &#x27;j&#x27; 178 BINARY_SUBSCR 180 LOAD_METHOD upper 182 CALL_METHOD_0 0 &#x27;&#x27; 184 CALL_FUNCTION_1 1 &#x27;&#x27; 186 STORE_FAST &#x27;y&#x27; 188_0 COME_FROM 170 &#x27;170&#x27; L. 107 188 LOAD_FAST &#x27;x&#x27; 190 LOAD_CONST 0 192 BINARY_SUBSCR 194 LOAD_FAST &#x27;y&#x27; 196 LOAD_CONST 0 198 BINARY_SUBSCR 200 COMPARE_OP == 202_204 POP_JUMP_IF_FALSE 268 &#x27;to 268&#x27; L. 108 206 LOAD_FAST &#x27;plaintext&#x27; 208 LOAD_FAST &#x27;T_letter&#x27; 210 LOAD_FAST &#x27;x&#x27; 212 LOAD_CONST 0 214 BINARY_SUBSCR 216 BINARY_SUBSCR 218 LOAD_FAST &#x27;x&#x27; 220 LOAD_CONST 1 222 BINARY_SUBSCR 224 LOAD_CONST 1 226 BINARY_SUBTRACT L. 109 228 LOAD_CONST 5 L. 108 230 BINARY_MODULO 232 BINARY_SUBSCR L. 109 234 LOAD_FAST &#x27;T_letter&#x27; 236 LOAD_FAST &#x27;y&#x27; 238 LOAD_CONST 0 240 BINARY_SUBSCR 242 BINARY_SUBSCR 244 LOAD_FAST &#x27;y&#x27; 246 LOAD_CONST 1 248 BINARY_SUBSCR 250 LOAD_CONST 1 252 BINARY_SUBTRACT 254 LOAD_CONST 5 256 BINARY_MODULO 258 BINARY_SUBSCR L. 108 260 BINARY_ADD 262 INPLACE_ADD 264 STORE_FAST &#x27;plaintext&#x27; 266 JUMP_ABSOLUTE 406 &#x27;to 406&#x27; 268_0 COME_FROM 202 &#x27;202&#x27; L. 110 268 LOAD_FAST &#x27;x&#x27; 270 LOAD_CONST 1 272 BINARY_SUBSCR 274 LOAD_FAST &#x27;y&#x27; 276 LOAD_CONST 1 278 BINARY_SUBSCR 280 COMPARE_OP == 282_284 POP_JUMP_IF_FALSE 348 &#x27;to 348&#x27; L. 111 286 LOAD_FAST &#x27;plaintext&#x27; 288 LOAD_FAST &#x27;T_letter&#x27; 290 LOAD_FAST &#x27;x&#x27; 292 LOAD_CONST 1 294 BINARY_SUBSCR 296 LOAD_CONST 1 298 BINARY_SUBTRACT L. 112 300 LOAD_CONST 5 L. 111 302 BINARY_MODULO 304 BINARY_SUBSCR L. 112 306 LOAD_FAST &#x27;x&#x27; 308 LOAD_CONST 0 310 BINARY_SUBSCR L. 111 312 BINARY_SUBSCR L. 112 314 LOAD_FAST &#x27;T_letter&#x27; 316 LOAD_FAST &#x27;y&#x27; 318 LOAD_CONST 1 320 BINARY_SUBSCR 322 LOAD_CONST 1 324 BINARY_SUBTRACT 326 LOAD_CONST 5 328 BINARY_MODULO 330 BINARY_SUBSCR 332 LOAD_FAST &#x27;y&#x27; 334 LOAD_CONST 0 336 BINARY_SUBSCR 338 BINARY_SUBSCR L. 111 340 BINARY_ADD 342 INPLACE_ADD 344 STORE_FAST &#x27;plaintext&#x27; 346 JUMP_ABSOLUTE 406 &#x27;to 406&#x27; 348_0 COME_FROM 282 &#x27;282&#x27; L. 114 348 LOAD_FAST &#x27;plaintext&#x27; 350 LOAD_FAST &#x27;T_letter&#x27; 352 LOAD_FAST &#x27;x&#x27; 354 LOAD_CONST 0 356 BINARY_SUBSCR 358 BINARY_SUBSCR 360 LOAD_FAST &#x27;y&#x27; 362 LOAD_CONST 1 364 BINARY_SUBSCR 366 BINARY_SUBSCR 368 LOAD_FAST &#x27;T_letter&#x27; 370 LOAD_FAST &#x27;y&#x27; 372 LOAD_CONST 0 374 BINARY_SUBSCR 376 BINARY_SUBSCR 378 LOAD_FAST &#x27;x&#x27; 380 LOAD_CONST 1 382 BINARY_SUBSCR 384 BINARY_SUBSCR 386 BINARY_ADD 388 INPLACE_ADD 390 STORE_FAST &#x27;plaintext&#x27; L. 115 392_394 BREAK_LOOP 406 &#x27;to 406&#x27; 396_0 COME_FROM 100 &#x27;100&#x27; L. 116 396 LOAD_FAST &#x27;j&#x27; 398 LOAD_CONST 1 400 INPLACE_ADD 402 STORE_FAST &#x27;j&#x27; 404 JUMP_BACK 72 &#x27;to 72&#x27; 406_0 COME_FROM 82 &#x27;82&#x27; L. 117 406 LOAD_FAST &#x27;j&#x27; 408 LOAD_CONST 1 410 BINARY_ADD 412 STORE_FAST &#x27;i&#x27; L. 118 414 JUMP_BACK 32 &#x27;to 32&#x27; 416 JUMP_FORWARD 430 &#x27;to 430&#x27; 418_0 COME_FROM 60 &#x27;60&#x27; L. 120 418 LOAD_FAST &#x27;plaintext&#x27; 420 LOAD_FAST &#x27;ciphertext&#x27; 422 LOAD_FAST &#x27;i&#x27; 424 BINARY_SUBSCR 426 INPLACE_ADD 428 STORE_FAST &#x27;plaintext&#x27; 430_0 COME_FROM 416 &#x27;416&#x27; L. 121 430 LOAD_FAST &#x27;i&#x27; 432 LOAD_CONST 1 434 INPLACE_ADD 436 STORE_FAST &#x27;i&#x27; 438 JUMP_BACK 32 &#x27;to 32&#x27; 440_0 COME_FROM 42 &#x27;42&#x27; L. 123 440 LOAD_FAST &#x27;plaintext&#x27; 442 RETURN_VALUE -1 RETURN_LAST Parse error at or near `JUMP_FORWARD&#x27; instruction at offset 416if __name__ == &#x27;__main__&#x27;: key = &#x27;YWCNOPJAFGHDTULMQXZEBRVKS&#x27; flag_enc = &#x27;WYTFSQOYGYOQKJLHUE&#x27; Create_Matrix(key) print(&#x27;Please Input flag: &#x27;) plaintext = input() if plaintext[0:7] != &#x27;moectf&#123;&#x27; or plaintext[(-1)] != &#x27;&#125;&#x27;: print(&#x27;Ruaaaaa~Wrong!&#x27;) input() exit() else: plaintext = plaintext[7:-1] flag = Encrypt(plaintext, T_letter) if flag != flag_enc: print(&#x27;Ruaaaaa~Wrong!&#x27;) input() exit() else: print(&#x27;Congratulations!&#x27;) input() exit() 看着这“夹生”的代码，我内心反复着mmp~~~但是突然有个点：两个没有完全解析的函数Encrypt、Decrypt……等下！！！Decrypt函数给出来了？那我们拿着解密函数不用不是对不起它么： 12345678import puzzlekey = &#x27;YWCNOPJAFGHDTULMQXZEBRVKS&#x27;cipher = &#x27;WYTFSQOYGYOQKJLHUE&#x27;puzzle.Create_Matrix(key)print(puzzle.T_letter)print(puzzle.Decrypt(cipher,puzzle.T_letter)) en???这么简单？？？就是这么简单……想不到吧~~~啦啦啦啦啦啦~~~ Flower这个题讲真好难！！！这里先感谢一下void大神对我的指导，void永远是我大哥！！！ 好了，下来开始正题： 根据题目名称flower，盲猜本题考查花指令，拖进IDA分析，扣符号表死马……F12查看字符串，这里有一个小点，就是我们要让我们的IDA显示中文字符。根据字符串定位main函数： F5大法，然后稍微改一改变量名（这样子，能舒服一些……找到对数据处理的函数： 经过这一部分处理后的结果和byte_4032AC进行比较： 跟进off_4032A4: 分别跟进两个函数，发现loc_401310存在花指令： 我们手动patch一下，把40133B修改成nop：点在40133B，按U，切换到hex-view，F2修改74为90，F2保存，切换回IDA view，按C，点击401310，按P： 这个函数等效于： 12for(int i=0;i&lt;16;i++) input[i] = 16 * (inpout[result] ^ 0x16) | ((inpout[result] ^ 0x16) &gt;&gt; 4); 然后我们跟进sub_4011B0： 然后查看off_404018: 跟进loc_4012B0，发现花指令，和之前的那个一样，按照上面说的处理： 跟进loc_401240，也是花指令，处理掉： 跟进loc_401270，还是花指令，处理掉： 我们现在相当于是把整个程序分析差不多了，我们现在理一下程序的思路：主函数调用func1（loc_401310）、func2（sub_4011B0）；func2又调用fun0（sub_4012B0）、fun1（sub_401240）、fun2（sub_401270）；func2又返回sub_4012D0函数。最后再跟byte_4032AC比较。我们现在需要弄清sub_4012D0函数在干什么，先试着用IDA分析一下： 貌似不太行……我们改动态调试： F9开始运行，输入0123456789abcdef，在断点处记录数据： 得知这个函数就是在挨个异或，每一位对应异或的内容是77,76,71,80,75,70,67,74,69,78,73,72,68,66,65。我们现在就可以写一个流程一样的程序，便于我们理解（便于写暴力，狗头.jpg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;unsigned char input[20];int rel[20]=&#123;62,254,153,118,139,220,13,24,50,120,111,191,67,116,51,115&#125;;void fun0(int x1,int x2)&#123; input[x1] += x2; return;&#125;void fun1(int x1,int x2)&#123; input[x1] ^=input[x2]; return;&#125;void fun2(int x1,int x2)&#123; input[x1] = abs(input[x1]-input[x2]); return;&#125; void func1()&#123; for(int i=0;i&lt;16;i++) &#123; input[i] = 16 * (input[i] ^ 0x16) | ((input[i] ^ 0x16) &gt;&gt; 4); &#125; return;&#125;void func2()&#123; fun0(0,1); fun1(1,2); fun2(2,3); fun1(3,4); fun2(4,5); fun0(5,6); fun0(6,7); input[0]^=0x4D; input[1]^=0x4C; input[2]^=0x47; input[3]^=0x50; input[4]^=0x4B; input[5]^=0x46; input[6]^=0x43; input[7]^=0x4A; input[8]^=0x45; input[9]^=0x4E; input[10]^=0x49; input[11]^=0x48; input[12]^=0x44; input[13]^=0x42; input[14]^=0x41; return;&#125;int main()&#123; cin&gt;&gt;input; if(strlen(input)&lt;16) return 0; func1(); func2(); for(int i=0;i&lt;16;i++) if(input[i]!=rel[i]) return 0; cout&lt;&lt;&quot;you&#x27;re right&quot;; return 0;&#125; 现在的话如果懒得逆向，你可以试试暴力，16位，你加油（狗头 我们现在逆向一下就ok了，没什么说的了，直接贴脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;unsigned char ori[20]=&#123;62,254,153,118,139,220,13,24,50,120,111,191,67,116,51,115&#125;;unsigned char input[20];void ini()&#123; for(int i=0;i&lt;16;i++) input[i]=ori[i]; return;&#125;int main()&#123; unsigned char ori[20]=&#123;62,254,153,118,139,220,13,24,50,120,111,191,67,116,51,115&#125;; unsigned char input[20]; for(int i=0;i&lt;16;i++) input[i]=ori[i]; input[0]^=0x4D; input[1]^=0x4C; input[2]^=0x47; input[3]^=0x50; input[4]^=0x4B; input[5]^=0x46; input[6]^=0x43; input[7]^=0x4A; input[8]^=0x45; input[9]^=0x4E; input[10]^=0x49; input[11]^=0x48; input[12]^=0x44; input[13]^=0x42; input[14]^=0x41; input[6]-=7; input[5]-=6; input[0] -= 1; for(int i=0;i&lt;16;i++) ori[i]=input[i]; input[4] += input[5]; input[3] ^=input[4]; input[2] = input[3]-input[2]; input[1] ^=input[2]; for(int k=0;k&lt;16;k++) &#123; input[k] = (16 * input[k] | (input[k] &gt;&gt; 4)); input[k] ^= 0x16; cout&lt;&lt;input[k]; &#125; cout&lt;&lt;&quot;\\n\\n&quot;; return 0;&#125; 对了，忘记说了。如果IDA里面显示的是unsigned char，你的程序也一定要用unsigned char，尤其是程序中间的处理涉及位运算。 我没做出来的GoOooO0OoEasyAlgorithmEasy C++","categories":[{"name":"CTF比赛题解","slug":"CTF比赛题解","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF,RE","slug":"CTF-RE","permalink":"http://example.com/tags/CTF-RE/"}],"author":"BlackBird"},{"title":"2020moectf Crypto","slug":"2020moectf-Crypto","date":"2020-10-13T03:00:20.000Z","updated":"2021-02-21T08:43:41.454Z","comments":true,"path":"2020/10/13/2020moectf-Crypto/","link":"","permalink":"http://example.com/2020/10/13/2020moectf-Crypto/","excerpt":"我的密码学是真的烂，，，唉~只能做一些简单题（数学太差","text":"我的密码学是真的烂，，，唉~只能做一些简单题（数学太差 我会做的crypto入门指北感谢shallow大佬送的学习资料~~ Stream这个题目有点毒瘤，，，先贴加密脚本 1234567import base64flag = &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;xor = ?print(len(xor))print(base64.b64encode((&quot;&quot;.join([chr(ord(i)^ord(xor)) for i in list(flag)])).encode(&quot;ASCII&quot;)))#1#b&#x27;Og9hNAFrCjU9aQ4+C2psLzxpYRE6azw+FmphPgk2EjQBDyw+DWsKIQIPHiwAaBYoOx8wNBU2aGU=&#x27; 一看xor就一位，爆破！！！ 12345678910111213import base64f = open(&quot;out2.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;)flag = b&#x27;Og9hNAFrCjU9aQ4+C2psLzxpYRE6azw+FmphPgk2EjQBDyw+DWsKIQIPHiwAaBYoOx8wNBU2aGU=&#x27;flag = base64.b64decode(flag)f.write(&quot;\\n————————————————开始爆破————————————————\\n\\n\\n&quot;)for i in range(0,128): f.write(str(i)) ans=&quot;&quot; for j in flag: ans = ans + (chr(i^j)) f.write(ans) f.write(&quot;\\n————————————————————分割线——————————————————————\\n\\n&quot;) 但为什么我觉得这个题目有点毒瘤，，，因为它解出来不是flag，而是flag的base64……最早真的没有想到这一点 moectf{U_Kn0w_How_7o_Break_Stream_Ciphe2} easycrypto直接暴力搞： 12345678910111213141516171819202122232425from FLAG import flagdef enc(plain): cipher = [] for i in plain: m = ord(i) cipher.append(5 * m ** 2 + 6 * m - 8) return cipherprint(enc(flag))#[60051, 62263, 51603, 49591, 67968, 52624, 76375, 38359, 51603, 58960, 49591, 62263, 60051, 51603, 45687, 67968, 62263, 45687, 22839, 65656, 73923, 63384, 67968, 62263, 78867]cnt=1flag_en=[60051, 62263, 51603, 49591, 67968, 52624, 76375, 38359, 51603, 58960, 49591, 62263, 60051, 51603, 45687, 67968, 62263, 45687, 22839, 65656, 73923, 63384, 67968, 62263, 78867]for i in flag_en: cnt+=1 for j in range(48,130): if(5*j**2+6*j-8==i): print(chr(j),end=&#x27;&#x27;) #moectf&#123;Welcome_to_Crypto&#125; rsa_begin毕竟是第一题，工具直接搞就完了，贴一篇工具教程,直接一把梭。 moectf{Ull_f1nd_RSA_1s_1nte2est1ng} 我没做出来的静等官方wp","categories":[{"name":"CTF比赛题解","slug":"CTF比赛题解","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF,Crypto","slug":"CTF-Crypto","permalink":"http://example.com/tags/CTF-Crypto/"}],"author":"BlackBird"},{"title":"2020moectf Web","slug":"2020moectf-Web","date":"2020-10-12T16:26:08.000Z","updated":"2021-02-21T08:43:06.633Z","comments":true,"path":"2020/10/13/2020moectf-Web/","link":"","permalink":"http://example.com/2020/10/13/2020moectf-Web/","excerpt":"作为一个二进制手……我把web强行做完，我太难了……","text":"作为一个二进制手……我把web强行做完，我太难了…… GET POST 小饼干小饼干？cookie！ url解码： 1moectf&#123;y0u_c4n&#39;t_e4t_thi3_c00k1e&#125; Introduction 进入网页，Ctrl+U看源码，Ctrl+F搜索 一句话一句话木马还是一个比较常见的考点， 现在直接AntSword或者Cknife一把梭，建议AntSword,,, moectf{0hhhh!!!y0u_know_h0w_to_u3e_eva1} EzMath刷新那么快，肯定不能用手来算，这块就需要用脚本，这个题特别像bugku的一道题目：秋名山老司机。找了找之前的笔记，就有了这样一个脚本： 123456789import requestsimport reurl = &#x27;http://39.98.86.109:10001/index.php&#x27;s = requests.Session()source = s.get(url)expression = re.search(r&#x27;(\\d+[+\\-*])+(\\d+)&#x27;, source.text).group()result = eval(expression)post = &#123;&#x27;a&#x27;: result&#125;print(s.post(url, data = post).text) 淦！！！复现的时候环境没了，，这里贴一下秋名山老司机这个题。可以尝试着把我上面的脚本改一下~ 三心二意先贴源码： 12345678910111213141516171819202122232425262728293031323334353637&lt;?php$a = $_GET[&#x27;a&#x27;];$b = $_POST[&#x27;b&#x27;];$c = $_REQUEST[&#x27;c&#x27;];$d = $_COOKIE[&#x27;d&#x27;];if (!isset($a, $b, $c, $d)) &#123; highlight_file(__FILE__);&#125; else &#123; if (is_numeric($a) and $a == false) &#123; //a=0 echo &#x27;A is OK!&#x27;; echo &#x27;&lt;br/&gt;&#x27;; if (!is_numeric($b) and $b == 0x125e591) &#123; //b=19260817a echo &#x27;B is OK!&#x27;; echo &#x27;&lt;br/&gt;&#x27;; if ($c != 240610708 and md5($c) == md5(240610708)) &#123; //c=s214587387a echo &#x27;C is OK!&#x27;; echo &#x27;&lt;br/&gt;&#x27;; if (strlen($d) &lt; 7 and $d != 0 and $d ** 2 == 0) &#123; //d[]= include(&#x27;/flag&#x27;); &#125; else &#123; echo &quot;D is not wanted.&lt;br/&gt;&quot;; highlight_file(__FILE__); &#125; &#125; else &#123; echo &quot;C is not wanted.&lt;br/&gt;&quot;; highlight_file(__FILE__); &#125; &#125; else &#123; echo &quot;Too young too simple.&lt;br/&gt;&quot;; highlight_file(__FILE__); &#125; &#125; else &#123; echo &quot;A is not wanted.&lt;br/&gt;&quot;; highlight_file(__FILE__); &#125;&#125; 一看就知道这个题目考察的是php语言的一些小tricks，先把a,b,c,d四个变量都设置值，然后再一个一个调 a不解释，，， b不解释，，， c是md5绕过，可以看下这篇文章 d不解释，，， 就这吧~爱会消失对不对 俄罗斯头套这个题，没做过类似的，现场百度，查到这个题的考点是http响应头，那么这个题也就没什么说的了，抓包，改响应头……就完了 这里放两张修改后的： moectf{r3que5t_he4der_1s_ea5y!!} include盲猜文件包含漏洞，，，点开do not click？？？我偏要click，然后看源码： 果然，和猜的一样。 先试一下： 好吧，我想的有点简单了。他的flag应该是在注释里面，那我们把整个文件base64一下就好了：","categories":[{"name":"CTF比赛题解","slug":"CTF比赛题解","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF,web","slug":"CTF-web","permalink":"http://example.com/tags/CTF-web/"}],"author":"BlackBird"},{"title":"2020moectf Algorithm","slug":"2020moectf-Algorithm","date":"2020-10-12T16:19:41.000Z","updated":"2021-02-21T08:44:44.042Z","comments":true,"path":"2020/10/13/2020moectf-Algorithm/","link":"","permalink":"http://example.com/2020/10/13/2020moectf-Algorithm/","excerpt":"这次的算法题，，，怎么说，，感觉真正考察算法的我都没写，就写了些不考察真正算法的题目","text":"这次的算法题，，，怎么说，，感觉真正考察算法的我都没写，就写了些不考察真正算法的题目 mess 12345678910111213141516import randomflag = &#x27;moectf&#123;xxxxxxxxxxx&#125;&#x27;digit = &#x27;&#x27;for i in flag: digit += str(ord(i))i = 0while i &lt; len(digit): n = random.randint(0, 128) if ord(&#x27;a&#x27;) &lt;= n &lt;= ord(&#x27;z&#x27;) or ord(&#x27;A&#x27;) &lt;= n &lt;= ord(&#x27;Z&#x27;): digit = digit[0:i] + chr(n) + digit[i:] i += 1with open(&#x27;puzzle.txt&#x27;, &#x27;w&#x27;) as out: out.write(digit)# 1091111A01ruVJl99hw11Qv6i102xCYC1c2B31DIsz1tm212l11A1l610448re11BQ09549115951n154V895F115d49109h1m1210810j11w2A5 这个题说人话就是把flag的每一项转化成ASCII码全部列一排，再往之间插入字母。所以第一步把字母全部去除掉，然后手动把得到的一串数字分开，首先moectf{}的格式是确定的，然后大概眼睛瞅着，，就出来： 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a; cin&gt;&gt;a; for(int i=0;i&lt;a.size();i++) if(a[i]&gt;=&#x27;0&#x27; &amp;&amp; a[i]&lt;=&#x27;9&#x27;) cout&lt;&lt;a[i]; return 0;&#125; //1091111A01ruVJl99hw11Qv6i102xCYC1c2B31DIsz1tm212l11A1l610448re11BQ09549115951n154V895F115d49109h1m1210810j11w2A5//1091111019911610212311212111610448110954911595115489511549109112108101125 12345a=[109,111,101,99,116,102,123,112,121,116,104,48,110,95,49,115,95,115,48,95,115,49,109,112,108,101,125]for i in a: print(chr(i),end=&#x27;&#x27;)# 109,111,101,99,116,102,123,112,121,116,104,48,110,95,49,115,95,115,48,95,115,49,109,112,108,101,125# moectf&#123;pyth0n_1s_s0_s1mple&#125; Frank, 永远滴神 u1s1,这个题就是学习一下python怎么遍历文件夹，，害~看脚本吧： 12345678910111213141516171819202122232425import osfrom base64 import *count = 0path = &quot;自己的目录\\puzzle&quot;dirs1 = os.listdir(path)for i in dirs1: path_1 = os.path.join(path,i) dirs2 = os.listdir(path_1) for j in dirs2: path_2 = os.path.join(path_1,j) dirs3 = os.listdir(path_2) for k in dirs3: path_3 = os.path.join(path_2,k) dirs4 = os.listdir(path_3) for m in dirs4: path_4 = os.path.join(path_3,m) print(path_4) f=open(path_4) file = f.read() f.close() count += file.count(&#x27;FrankNB!&#x27;)print(count.b64encode())#moectf&#123;MjA1MjMy&#125; 赤道企鹅, 永远滴神 这个题就比前一个多一个数据处理，，，所以也没什么说的，直接贴脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142import osfrom base64 import *count_n = 0count_y = 0count = 0path = &quot;H:\\Competitions\\moectf\\Algorithm\\Eqqie\\puzzle&quot;dirs1 = os.listdir(path)for i in dirs1: path_1 = os.path.join(path,i) dirs2 = os.listdir(path_1) for j in dirs2: path_2 = os.path.join(path_1,j) dirs3 = os.listdir(path_2) for k in dirs3: path_3 = os.path.join(path_2,k) dirs4 = os.listdir(path_3) for m in dirs4: path_4 = os.path.join(path_3,m) print(path_4) #遍历文件 f = open(path_4) file = f.read() f.close() #读取文件 if file[7]==&#x27;?&#x27;: count_n += 1 continue count_y += 1 a = &quot;&quot; a += file[7:] flag = 1 for i in a: if (&#x27;9&#x27;&gt;=i&gt;=&#x27;0&#x27; or &#x27;z&#x27;&gt;=i&gt;=&#x27;a&#x27; or &#x27;Z&#x27;&gt;=i&gt;=&#x27;A&#x27;): if flag==1: flag = 0 count += 1 else: flag=1ans=str(count).encode() print(b64encode(ans))#moectf&#123;MTgyNDI2&#125; 千层饼 先放一下加密脚本吧： 123456789101112131415from base64 import *from random import Randomfrom flag import flagalg = [b16encode, b32encode, b64encode, a85encode, b85encode]r = Random()for i in range(r.randrange(35,40)): er = r.choice(alg) flag = r.choice(alg)(str(alg.index(er)).encode()) + b&#x27;eqqie_is_god&#x27; + er(flag)with open(&#x27;secret.txt&#x27;,&#x27;wb&#x27;) as out: out.write(flag)with open(&#x27;puzzle.txt&#x27;, &#x27;wb&#x27;) as out: out.write(flag) 这个题的思路还是挺显而易见的，，，说白了就是“套娃”。这个题我先半手撕掉了，然后又写了全自动的脚本，半手撕的就不贴了，给个全自动的吧~~： 12345678910111213141516171819202122232425262728293031323334from base64 import *dict=&#123;&#125;def ini(): for i in range(len(alg)): for j in range(5): tmp = alg[i](str(j).encode()) dict[tmp] = jalg = [b16encode, b32encode, b64encode, a85encode, b85encode]alg_s = [b16decode, b32decode, b64decode, a85decode, b85decode]with open(&#x27;puzzle.txt&#x27;,&#x27;r&#x27;) as f: data = f.read()print(&quot;index：&quot;)for i in range(len(alg)): print(&quot; &quot;,i,&quot;: &quot;,alg[i])ini()count = 0print(dict)while 1: if &#x27;eqqie_is_god&#x27; not in data: print(data) break key = data.index(&#x27;eqqie_is_god&#x27;) print(data[:key]) data = alg_s[int(dict[data[:key].encode()])](data[key+12:]).decode() count = count+1 print(count) print()# moectf&#123;so00Oo0oO_d31ici0us&#125; emmm。。。我自认为我的代码还是比较容易理解的。就这样吧~~","categories":[{"name":"CTF比赛题解","slug":"CTF比赛题解","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CTF,program","slug":"CTF-program","permalink":"http://example.com/tags/CTF-program/"},{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"}],"author":"BlackBird"},{"title":"2020moectf Classic Crypto","slug":"2020moectf-Classic-Crypto","date":"2020-10-08T18:13:41.000Z","updated":"2021-02-21T08:43:30.384Z","comments":true,"path":"2020/10/09/2020moectf-Classic-Crypto/","link":"","permalink":"http://example.com/2020/10/09/2020moectf-Classic-Crypto/","excerpt":"这次比赛竟然还有Classic Crypto专场，属实不易。然后我也把古典密码学做完了，占我总分的9.35。","text":"这次比赛竟然还有Classic Crypto专场，属实不易。然后我也把古典密码学做完了，占我总分的9.35。 大帝的征程#1 大帝 -&gt; 凯撒 -&gt; 凯撒密码 因为这是moectf比赛，所以flag一定是moectf打头，所以可以算得偏移，就出来了： 密文： zbrpgs{p0adh3e_gu3_j0eyq} 明文： moectf{c0nqu3r_th3_w0rld} 大帝的征程#2 这个题目，肯定还是凯撒，但是毕竟是#2了，所以是凯撒变种，但是试了试没什么思路，，，就开了hint： ![image-20201008094329085](/images/2020moectf Classic Crypto/image-20201008094329085.png) 看了hint，瞬间明白了，他时候一个换表凯撒，这个就得自己写脚本搞了： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string table=&quot;0abcdefghijklmnopqrstuvwxyz0123456789&quot;;//这里有个小问题，就是我给table前面加了一个0，用来占位，，，毕竟从1开始还是比较舒服 string a; cin&gt;&gt;a; for(int i=0;i&lt;a.size();i++) &#123; int temp; if(a[i]!=&#x27;&#123;&#x27; &amp;&amp; a[i]!=&#x27;&#125;&#x27; &amp;&amp; a[i]!=&#x27;_&#x27;) &#123; for(int j=1;j&lt;table.size();j++) &#123; if(table[j]==a[i]) &#123; int temp; temp=(j+36*2-i)%36; cout&lt;&lt;table[temp]; &#125; &#125; &#125; else cout&lt;&lt;a[i]; &#125; return 0;&#125; 密文： mpgfxk{j8w05q4_8xk_d7mhqfht}明文： moectf{c0nquer_th3_un1v3rs3} 外面的世界 外面的世界 + 密文盲猜 =&gt; 栅栏密码 在线解密， PS：做栅栏密码的时候一定要注意复制粘贴，别多复制空格了，，，你会解不出来的 密文： mc{i33ny_-n~otR1n_cp1FN}efaFc32Tsuy 明文： moectf{Rai1F3nc3_3nc2ypT_1s-FunNy~} 大帝的征程#3 啊这，，，这个密文出现了一些奇怪字符，应该是这个凯撒的table是整个ASCII表，，，然后想到（出题人提醒）在ASCII编码中有一种密码叫做ROT47，然后我们在线解密试一下： 密文： &gt;@64E7L4_?BF6C0E9b0)s$trN 明文： moectf{c0nquer_th3_XDSEC} 大帝的征程#维吉尼亚 u1s1这个题目我是手撕的，，，因为我们的答案最后肯定是moectf{……}，所以我们就用moectf，对应出key：dsecx 然后在线工具跑一下： 密文：pgieqi{k0_ajxW_k-R3zq?} 密钥： dsecx 明文： moectf{s0_whaT_s-N3xt?} 大帝的征程#维吉尼亚Ex 下载附件,然后搜索到密文：ooukot{ig3_oqf1_Ymiedmms_BzVn3_s0w_w0_3csO} 这个题的话，，我就提供两种思路吧： 手撕他说难撕就难撕么？？？ 我不信！我要试一试。 首先moectf绝对是没有问题的，又因为维吉尼亚只是字母在变化，数字没有改变，所以根据 3-&gt;e , 0-&gt;O以及部分密钥循环使用，我们可以猜一些东西 ig3-&gt;th3 , Ymiedmms -&gt; Vigenere , w0 -&gt; s0 , s0w -&gt; n0t , 3csO -&gt; 3asy……这个时候密钥好像就已经出来了（即使这个时候密钥没有完全出来，那么剩下1或者2个不确定的，暴力解决~~）。 密文： ooukot{ig3_oqf1_Ymiedmms_BzVn3_s0w_w0_3csO} 密钥： caqivopzxmfde 明文： moectf{th3_rea1_Vigenere_MaYb3_n0t_s0_3asY} 正解这里有一种方法叫做“重合指数对照”来破解维吉尼亚密码，在线工具在这里~~ ![image-20201009013434884](/images/2020moectf Classic Crypto/image-20201009013434884.png) 要是知道密钥的长度并且填上去会快一点，但要是什么也不填，这个网站也挺快的~~ moectf{th3_rea1_vigenere_mayb3_n0t_s0_3asy}","categories":[{"name":"CTF比赛题解","slug":"CTF比赛题解","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF,Crypto","slug":"CTF-Crypto","permalink":"http://example.com/tags/CTF-Crypto/"}],"author":"BlackBird"},{"title":"2020moectf-MISC","slug":"2020moectf-MISC","date":"2020-10-07T18:04:10.000Z","updated":"2021-02-21T08:44:04.028Z","comments":true,"path":"2020/10/08/2020moectf-MISC/","link":"","permalink":"http://example.com/2020/10/08/2020moectf-MISC/","excerpt":"写在前面：这次moectf，misc一共17道，做出来了14道。然后最后发现misc占我总分比重22%左右，占比最高？好的我是misc手（~~~二进制手~~~）。然后这个方面wp也比较好写，就先写了misc的wp。然后没做的道题，等官方题解吧，，，真的不会了……","text":"写在前面：这次moectf，misc一共17道，做出来了14道。然后最后发现misc占我总分比重22%左右，占比最高？好的我是misc手（~~~二进制手~~~）。然后这个方面wp也比较好写，就先写了misc的wp。然后没做的道题，等官方题解吧，，，真的不会了…… 我做出来的welcome 两个下载下来：一张图片和一个入门指南 图片： 毕竟是第一个题目嘛~~~应该不难。用winhex瞅瞅： flag： moectf{Jo1n_0ur_professional_group} 然后吧，，，那个pdf写的挺好的，，，留下来研读…… MD5 这么，，恶臭，，，一定是flag了…… flag：moectf{114514} Base64 密文：bW9lY3RmJTdCZXpfYjY0JTIxJTdE 解密后：moectf{ez_b64!} hey fxck you! 下载下来是一个图片： 盲猜图片隐写：binwalk搞一下，得到这么一串奇奇怪怪的东西 ++++++++[&gt;&gt;++&gt;++++&gt;++++++&gt;++++++++&gt;++++++++++&gt;++++++++++++&gt;++++++++++++++&gt;++++++++++++++++&gt;++++++++++++++++++&gt;++++++++++++++++++++&gt;++++++++++++++++++++++&gt;++++++++++++++++++++++++&gt;++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;—.++.&lt;+++++.–.&gt;+++++.&lt;+++.&gt;&gt;—–.–.&lt;&lt;-.&gt;-.&lt;&lt;&lt;&lt;&lt;+.&gt;&gt;&gt;&gt;&gt;&gt;.&lt;&lt;.&gt;.&lt;&lt;&lt;&lt;&lt;.&gt;&gt;&gt;&gt;+.+++++.————.&lt;+++++.&gt;.&lt;&lt;&lt;++.&lt;.&gt;&gt;&gt;&gt;&gt;&gt;++++. 这个的话，联系题目名字加上经验（其实要是搜索用的好，是可以搜出来的 这个编码叫做brain fuck，然后在线解密就完了 1moectf&#123;yes!yes!fk_U_2!&#125; Base64？¿ 顺手点开hint： vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/ 好了，base64换表，上脚本： 123456789import base64import stringstr1 = &quot;0H9MJjCNPiMgJHMQJNtfyEJgIjtS1Ig=&quot; # 密文string1 = &quot;vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/&quot; # 换表string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print (base64.b64decode(str1.translate(str.maketrans(string1,string2)))) moectf{itai_base64_qaq} Pseudo Encryption 这个题目刚开始出bug了，，， bug版下载下来是一个zip文件，解压带密码，但是不能用伪密码绕过。无奈之下，扔进winhex瞅瞅，然后就找到这么一串东西： 一看就是base64，，，在线解码，，盲猜url编码 正确版下载下来是一个zip，但是打不开，，， 扔进ultra editor，发现文件头不对，，，补个文件头 然后解压出来是个图片 然后就跟bug版一样了 密文：bW9lY3RmJTdCSnVzN19jNmFuOWVfQF9iMXQlMjElN0Q= 解密： moectf%7BJus7_c6an9e_@_b1t%21%7D 再解密：moectf{Jus7_c6an9e_@_b1t!} 不 会 吧 ？ 就 这 ¿ 阴阳怪气编码，，，， 附件下载下来就是这个猫猫头，，， binwalk分离： 肯定是一个什么编码，，，换成0和1。因为只有两种内容，所以要么是二进制，要么是摩斯。尝试一下摩斯，不行，那就是二进制和ASCII码结合，，，这里写了一个C程序： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string flag=&quot; &quot;; for(int j=1;;j++) &#123; int ans=0; string a; cin&gt;&gt;a; if(a[0]==&#x27;#&#x27;) //用于停止循环 break; for(int i=0;i&lt;a.size();i++) if(a[i]==&#x27;.&#x27;) ans=ans+pow(2,i); char rel=ans; // cout&lt;&lt;ans&lt;&lt;&quot; : &quot;&lt;&lt;rel&lt;&lt;&quot;\\n&quot;; flag[j]=rel; &#125; cout&lt;&lt;flag; return 0;&#125; 然后把转换后的内容输进去就有答案啦~~ moectf{Y0u_wh4t?-0n1y_th1S?} Cor1e的支票 附件下载下来打开是这个亚子： 。。。。。。。。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。。。。。。。。。？。？！。？。。。。。。。。。。。。。。。。。。！。。。。。！。？。。。。。。。！？！！。？！！！！！！？。？！。？！！！。！！！！！。？。。。。。。。。。！？！！。？。。。。。。。。？。？！。？。。！。？。。。。。。。！？！！。？！！！！！！？。？！。？！！！！！！！！！！！。？。。。。。。。。。！？！！。？。。。。。。。。？。？！。？。。。。。。。。。。！。？。。。。。。。。。！？！！。？！！！！！！！！？。？！。？！！！！！！！！！！！！！！！！！。？。。。。。。。！？！！。？。。。。。。？。？！。？。。。。。。！。。。。。。。！。？。。。。。。。。。。。。。。。。。！？！！。？！！！！！！！！！！！！！！！！？。？！。？！！！。？。。。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。。。？。？！。？。。。。。。！。！！！！！！！！！！！！！。？。。。。。。。。。。。！？！！。？！！！！！！！！！！？。？！。？！！！！！！！！！！！。？。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。？。？！。？。。。。。。。。。。。。。。。。。。！。？。。。。。。。。。。。。。！？！！。？！！！！！！！！！！！！？。？！。？！！！！！！！！！！！！！。？。。。。。。。。。。。！？！！。？。。。。。。。。。。？。？！。？。。。。！。。。。。。。。。。。。。！。？。。。。。。。。。。。。。。。！？！！。？！！！！！！！！！！！！！！？。？！。？！！！。？。。。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。。。？。？！。？。。。。。。。。。。。。。。。。。。。。。。。。。。！。！！！！！！！！！！！！！！！！！。！！！！！！！！！。！！！！！！！！！！！！！。？。。。。。。。。。。。。。！？！！。？！！！！！！！！！！！！？。？！。？！！！！！！！！！！！！！！！！！！！！！。？。。。。。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。。。。。？。？！。？。。。。！。？。。。。。。。。。！？！！。？！！！！！！！！？。？！。？！！！！！！！！！。？。。。。。。。。。。。！？！！。？！！！！！！！！！！？。？！。？！！！！！！！。？。。。。。。。！？！！。？。。。。。。？。？！。？。。。。。。。。！。？。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。？。？！。？。。。。。。。。。。。。。。。。。。！。？。 emmm……….肯定是一个编码啊，，，然后查一下，，，发现有一个编码叫做Ook编码和前面的Brain fuck一个作者，，，然后加上Ook，在线解码： moectf{cor1e_AnD_e3qie_1s_CP} 内心OS：#？!#$@?@**!@%#%^&amp;@%@# 简单的社工题目 这个题狠毒瘤，，， 第三个图片，，，他的关注，你逆着看： &#57;&#x32;&#51;&#x34;&#x33;&#49;&#x40;&#x6f;&#x75;&#x72;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#110; ，进去后要输入密码，这里我是爆破出来的，但是其实是弱口令：a123456，进去了后看到一串神秘代码： 底下还有个这个： 盲猜百度网盘（其实我开hint了，，，然后就可以得到flag了 A3FXCK 下载是一个图片，binwalk干他！！！ 然后发现这样一个东西： luoq1an -&gt; 1 -&gt;[ arttnba2 -&gt; 2 -&gt;] arttnba3 -&gt; 3 -&gt;( luoqi4n -&gt; 4 -&gt;) arttnba5 -&gt; 5 -&gt; + arttnba6 -&gt; 6 -&gt; ! 代换以后，根据“+!”这6个符号以及题干信息，知道这是JS fuck编码，再浏览器的控制台里或者在线解密一下： moectf{J5Fxck_1s_1nt3res7in9!} ⑨的完美教室 我觉得这个题是真的毒瘤，，， 看到nc连上去： ？？？ 数学不好？？？ 然后发现一直输入9，，，没有任何问题 我就很懵逼，还社工了一下这个动漫人物。。。。。 开了hint才知道，，，这TM就是一个pwn题 真的艹，，，这个题 上脚本： 123456789from pwn import *p = remote(&#x27;sec.arttnba3.cn&#x27;,10001)while True: recv = p.recv() p.sendline(&#x27;9&#x27;) if b&#x27;ctf&#x27; in recv: print(recv) break 挂一下某个毒瘤出题人 moectf{c1rn0_1s_tH3_5tr0n9est!} 停不下来了啊啊啊啊啊啊啊 这题能把人笑死，，， 下载下来是一个视频，然后唱了一会歌，就听他“啊啊啊啊啊~~”，，， 突然看到一道黑影一闪而过，，，嗯？好像是个flag？拖到Pr里面一帧一帧的看，，，看到了！！！ 艹，，，才一点，但最起码思路正确，然后一看全长：4h，，，瞬间自闭 但u1s1，hint还是很给力的，，，下载ffmpeg，侦测黑场帧，百度了老久用法，，， $ ffmpeg -loglevel info -i final.mp4 -vf blackframe=95:30 -f null - 然后把结果复制下来： 但是哟一个问题，，这里的黑场帧对应的是时间戳（实在找不到显示帧数或者时间的方法），，，于是只能用时间戳en上，看一眼视频帧率30，那就用时间戳/帧率就是秒数，再转化时间，在那个大致范围里面一点一点找，，，（还是在啊~~）最后终于集齐龙珠，召唤神龙（bushi，获得flag moectf{G0d_Of-Vid3o+Edit1ng_AnD_ffmp3G} 星空 下载下来解压是一张图片，binwalk分离，然后发现420张图片……woc这是在考察我5岁之前的技能啊——拼图，但是手拼有失水准（其实是根本拼不来。所以这个题，需要用一个工具：gaps，这个东西环境比较难安装（windows辣鸡…… 我是在我的虚拟机上安装的，然后先用montage把这些块块拼成一个图片，然后再用gaps拼图…… montage *jpg -geometry 100x100+0+0 out2.jpg gaps –image out2.jpg –generations 2000 –population 420 –size 100 当时github上面readme的指令没一个能用……readme辣鸡。然后只能靠百度了，搜了老久,然后自己手调才试出来的…… 但是，不管怎么调整参数，拼图始终不能完美，，最好的结果就是这个： 还好我不是电竞选手： moectf{thE_5t@rrY_sKy_1s_ReAlly_beauTifuL} Osu! Master! 之前打过osu，，但是我太菜了……所以就把osu卸载了，然后为了做题又安装上了。 下载附件是一个osu的谱子，进去打一打~~发现谱子上有一个moectf的黑旗子在闪烁，盲猜morse。但是……这个工具人好难啊，，然后在RX大佬的引导下，学习了osu制谱里面的Osu story board文件结构：在.osb文件里里面写着图片闪烁的时间参数，把他提取出来，发现图片显示的时间持续在270或者540，然后间隔的时间是270或者810，于是我手动把里面所有时间参数dump下来，然后写了一个转化成morse密文的py脚本： 1234567891011121314def change(a,b): if(b-a==270): return &#x27;.&#x27; else: return &#x27;-&#x27;dic=[2133,2673,2943,3213,3483,4023,4293,4833,5643,6183,6453,6993,7263,7803,8613,8883,9153,9423,9693,10233,11043,11313,11583,12123,12933,13203,13473,14013,14283,14553,15363,15633,16443,16983,17253,17793,18063,18603,19413,19683,19953,20223,20493,20763,21573,21843,22113,22383,22653,23193,24003,24543,24813,25353,26163,26433,26703,27243,28053,28323,28593,28863,29133,29403,30213,30753,31563,31833,32643,32913,33183,33723,33993,34263,35073,35343,35613,35883,36153,36423,37233,37773,38043,38583,38853,39393,40203,40473,40743,41013,41283,41553,42363,42903,43173,43713,43983,44523,45333,45603,45873,46143,46413,46683,47493,48033,48843,49113,49383,49923,50193,50463,51273,51813,52083,52623,52893,53433,54243,54783,55053,55323,56133,56673,56943,57483,57753,58023,58833,59373,60183,60453,60723,60993,61263,61533,61803,62073,62883,63153,63423,63693,64503,64773,65043,65313,65583,65853,66663,66933,67203,67473,67743,68283,68553,68823,69633,69903,70173,70713,70983,71253,71523,71793,72603,72873,73143,73683,74493,75033,75303,75843,76113,76383,77193,77733,78003,78543,78813,79083,79893,80163,80433,80703,81513,81783,82053,82323,82593,82863,83133,83673,84483,84753,85563,86103,86373,86643,86913,87453,87723,88263,89073,89613,89883,90423,90693,91233,92043,92313,92583,92853,93123,93663,94473,95013,95823,96363,96633,97173,97443,97983,98793,99063,99333,99873,100143,100413,101223,101493,102303,102573,102843,103383,103653,104193,105003,105273,105543,106083,106893,107163,107433,107973,108243,108513,109323,109863,110133,110403,110673,110943,111753,112293,112563,112833,113103,113643,113913,114453,115263,115803,116073,116613,116883,117423,118233,118503,118773,119043,119313,119853,120663,121203,121473,121743,122013,122283,123093,123633,123903,124443,124713,125253,126063,126603,126873,127143,127953,128493,128763,129303,129573,130113,130923,131463,132273,132543,132813,133353,134163,134433,134703,134973,135243,135783,136053,136323,137133,137403,137673,138213,138483,138753,139563,139833,140103,140643,141453,141723,141993,142263,143073,143613,143883,144153,144423,144693,145503,146043,146313,146853,147123,147663,148473,148743,149013,149283,149553,150093,150363,150633,151443,151713,151983,152253,153063,153603,154413,154683,154953,155223,155493,155763,156573,156843,157113,157653,157923,158193,158463,158733,159543,159813,160623,161163,161433,161703,162513,163053,163323,163863,164133,164403,165213,165753,166563,166833,167103,167373,167643,167913,168183,168453,169263,169533,169803,170073,170883,171423,172233,172503,172773,173043,173853,174123,174393,174663,174933,175203,176013,176553,177363,177633,177903,178173,178443,178713,178983,179253,180063,180333,181143,181413,181683,182223,182493,182763,183573,183843,184113,184383,185193,185733,186003,186543,186813,187083,187893,188163,188433,188703,188973,189243,189513,189783,190593,191133,191943,192213,192483,192753,193023,193563,193833,194103,194913,195183,195453,195993,196263,196533,196803,197073,197883,198153,198423,198963,199773,200313,200583,201123,201393,201663]cnt = 2print(change(dic[0],dic[1]),end=&#x27;&#x27;)while cnt&lt;len(dic): if dic[cnt]-dic[cnt-1]==810: print(&#x27;/&#x27;,end=&#x27;&#x27;) print(change(dic[cnt],dic[cnt+1]),end=&#x27;&#x27;) cnt=cnt+2# 结果：-.--/---/..-/.-/.-././---/.../..-/--/.-/.../-/./.-./.../---/.../---/.../-/.-./---/-./--./-/..../../.../..-./.-../.-/--./--./../...-/./-.--/---/..-/-/---/.-././.--/.-/.-./-../-.--/---/..-/-../---/-./---/-/.-/..-./.-./.-/../-../---/..-./../-/.../.-.././-./--./-/..../../-/../.../-/...././.-./../--./..../-/..-./.-../.-/--. 然后在线工具搞一下： YOUAREOSUMASTERSOSOSTRONGTHISFLAGGIVEYOUTOREWARDYOUDONOTAFRAIDOFITSLENGTHITISTHERIGHTFLAG moectf{YOUAREOSUMASTERSOSOSTRONGTHISFLAGGIVEYOUTOREWARDYOUDONOTAFRAIDOFITSLENGTHITISTHERIGHTFLAG} 我没做出来的参考了Dawnwhisper、-k0414-和arttnba的博客，剩下的三个题目：两只企鹅，show off，以及闪电风暴(不建议看或者做……)的题解就都有了~~大家可以点击移步到各位大佬的blog里面转一转。（要是有了官方wp我还会回来更新的~","categories":[{"name":"CTF比赛题解","slug":"CTF比赛题解","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF,misc","slug":"CTF-misc","permalink":"http://example.com/tags/CTF-misc/"}],"author":"BlackBird"}],"categories":[{"name":"电子取证学习","slug":"电子取证学习","permalink":"http://example.com/categories/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E5%AD%A6%E4%B9%A0/"},{"name":"CTF比赛题解","slug":"CTF比赛题解","permalink":"http://example.com/categories/CTF%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"电子取证","slug":"电子取证","permalink":"http://example.com/tags/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"},{"name":"CTF,RE","slug":"CTF-RE","permalink":"http://example.com/tags/CTF-RE/"},{"name":"CTF,Crypto","slug":"CTF-Crypto","permalink":"http://example.com/tags/CTF-Crypto/"},{"name":"CTF,web","slug":"CTF-web","permalink":"http://example.com/tags/CTF-web/"},{"name":"CTF,program","slug":"CTF-program","permalink":"http://example.com/tags/CTF-program/"},{"name":"CTF,misc","slug":"CTF-misc","permalink":"http://example.com/tags/CTF-misc/"}]}